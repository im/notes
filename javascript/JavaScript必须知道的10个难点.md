# JavaScript必须知道的10个难点
### 立即执行函数

**立即执行函数** ，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：

```js
(function() { 
		// 代码
})();
```

 
**function(){…}** 是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。 **立即执行函数** 也可以理解为立即调用一个匿名函数。 **立即执行函数** 最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。


### 闭包

对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/640.jpeg)

代码中，外部函数 **f1** 只执行了一次，变量 **N** 设为 **0** ，并将内部函数 **f2** 赋值给了变量 **result** 。由于外部函数 **f1** 已经执行完毕，其内部变量 **N** 应该在内存中被清除，然而事实并不是这样：我们每次调用 **result** 的时候，发现变量 **N** 一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！

### 使用闭包定义私有变量

通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/_640.jpeg)

代码中，对象 **p** 的的 **name** 属性为私有属性，使用 **p.name** 不能直接访问。

### prototype

每个JavaScript构造函数都有一个 **prototype** 属性，用于设置所有实例对象需要共享的属性和方法。 **prototype** 属性不能列举。JavaScript仅支持通过 **prototype** 属性进行继承属性和方法。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/__640.jpeg)

代码中， **x** 和 **y** 都是构造函数 **Rectangle** 创建的对象实例，它们通过prototype继承了getDimensions方法。

### 模块化

JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用 **立即执行函数** 来实现模块化，正如很多JS库比如jQuery以及我们Fundebug都是这样实现的。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/___640.jpeg)

所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块， **N** 为其私有属性， **print** 为其私有方法， **decription** 为其公有属性， **add** 为其共有方法。

### 变量提升

JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的 **变量提升(Hoisting)** 。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。

但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/____640.jpeg)

为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。

### 柯里化

柯里化，即 **Currying** ，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/_____640.jpeg)

代码中，我们可以一次性传入2个1作为参数 **add(1)(1)** ，也可以传入1个参数之后获取 **add1** 与 **add10** 函数，这样使用起来非常灵活。


### apply, call与bind方法

JavaScript开发者有必要理解 **apply**、**call** 与 **bind** 方法的不同点。它们的共同点是第一个参数都是 **this** ，即函数运行时依赖的上下文。

三者之中， **call** 方法是最简单的，它等价于指定 **this** 值调用函数：

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/______640.jpeg)
**apply** 方法与 **call** 方法类似。两者唯一的不同点在于， **apply** 方法使用数组指定参数，而 **call** 方法每个参数单独需要指定：

* **apply(thisArg, [argsArray])**

* **call(thisArg, arg1, arg2, …)**

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/_______640.jpeg)
使用 **bind** 方法，可以为函数绑定 **this** 值，然后作为一个新的函数返回：

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/________640.jpeg)

### Memoization

**Memoization** 用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/_________640.jpeg)


### 函数重载

所谓 **函数重载(method overloading)** ，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉， **函数重载** 可以通过 **if...else** 或者 **switch** 实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。

从效果上来说， **people** 对象的 **find** 方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。

难点在于， **people.find** 只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数 **find0**,**find1** 与 **find2** 啊！这里的关键在于 **old** 属性。

由 **addMethod** 函数的调用顺序可知， **people.find** 最终绑定的是 **find2** 函数。然而，在绑定 **find2** 时， **old** 为 **find1** ；同理，绑定 **find1** 时， **old** 为 **find0** 。3个函数 **find0**,**find1** 与 **find2** 就这样通过闭包链接起来了。

根据 **addMethod** 的逻辑，当 **f.length** 与 **arguments.length** 不匹配时，就会去调用 **old** ，直到匹配为止。

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/__________640.jpeg)

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/___________640.jpeg)

![](JavaScript%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E4%B8%AA%E9%9A%BE%E7%82%B9/____________640.jpeg)
**最后**

这10个就是我们比较常见的JavaScript学习难点，有些大家或许还没接触过，有些是已经掌握的了。不管怎么样，JavaScript都是前端开发工程师必备的技能点，如果你还没能掌握好JavaScript，一定要加把劲咯！

[原文链接](https://mp.weixin.qq.com/s/Lpz9YLXi4dQ1gzM_2EnoIQ)

#前端/JavaScript
