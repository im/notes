<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>实时协同编辑的实现 | 糖小米 .</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/notes/favicon.ico">
    <meta name="description" content="在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。

这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。

要实现实时编辑，我们需要解决两个技术点：实时通信问题、 ...">
    
    <link rel="preload" href="/notes/assets/css/0.styles.5f1d73a0.css" as="style"><link rel="preload" href="/notes/assets/js/app.a25c93c4.js" as="script"><link rel="preload" href="/notes/assets/js/7.4afd0a91.js" as="script"><link rel="preload" href="/notes/assets/js/1.208cd082.js" as="script"><link rel="preload" href="/notes/assets/js/48.64b07b58.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.457c0b89.js"><link rel="prefetch" href="/notes/assets/js/11.49994ff3.js"><link rel="prefetch" href="/notes/assets/js/12.203adc88.js"><link rel="prefetch" href="/notes/assets/js/13.87007fe1.js"><link rel="prefetch" href="/notes/assets/js/14.516c3649.js"><link rel="prefetch" href="/notes/assets/js/15.d48d3f5d.js"><link rel="prefetch" href="/notes/assets/js/16.6c452705.js"><link rel="prefetch" href="/notes/assets/js/17.8ecba909.js"><link rel="prefetch" href="/notes/assets/js/18.36bc938b.js"><link rel="prefetch" href="/notes/assets/js/19.0f77249b.js"><link rel="prefetch" href="/notes/assets/js/20.4b59908c.js"><link rel="prefetch" href="/notes/assets/js/21.d34e148b.js"><link rel="prefetch" href="/notes/assets/js/22.e7c5a065.js"><link rel="prefetch" href="/notes/assets/js/23.0ebf5e52.js"><link rel="prefetch" href="/notes/assets/js/24.ddd5f543.js"><link rel="prefetch" href="/notes/assets/js/25.3cae4432.js"><link rel="prefetch" href="/notes/assets/js/26.b83b303b.js"><link rel="prefetch" href="/notes/assets/js/27.5e0575c0.js"><link rel="prefetch" href="/notes/assets/js/28.8cda86ae.js"><link rel="prefetch" href="/notes/assets/js/29.a898a966.js"><link rel="prefetch" href="/notes/assets/js/30.cb2dc895.js"><link rel="prefetch" href="/notes/assets/js/31.ccd792fe.js"><link rel="prefetch" href="/notes/assets/js/32.f79945b3.js"><link rel="prefetch" href="/notes/assets/js/33.cc5ad000.js"><link rel="prefetch" href="/notes/assets/js/34.55f21b32.js"><link rel="prefetch" href="/notes/assets/js/35.7d11849f.js"><link rel="prefetch" href="/notes/assets/js/36.2b3f5028.js"><link rel="prefetch" href="/notes/assets/js/37.9d280264.js"><link rel="prefetch" href="/notes/assets/js/38.6aa338a6.js"><link rel="prefetch" href="/notes/assets/js/39.62855c36.js"><link rel="prefetch" href="/notes/assets/js/4.ffa57cc2.js"><link rel="prefetch" href="/notes/assets/js/40.4a4ba528.js"><link rel="prefetch" href="/notes/assets/js/41.2c98cb54.js"><link rel="prefetch" href="/notes/assets/js/42.53fca264.js"><link rel="prefetch" href="/notes/assets/js/43.767d9734.js"><link rel="prefetch" href="/notes/assets/js/44.faa33aea.js"><link rel="prefetch" href="/notes/assets/js/45.f01c4924.js"><link rel="prefetch" href="/notes/assets/js/46.b531a597.js"><link rel="prefetch" href="/notes/assets/js/47.f416912e.js"><link rel="prefetch" href="/notes/assets/js/49.4d861b33.js"><link rel="prefetch" href="/notes/assets/js/5.5d5ced76.js"><link rel="prefetch" href="/notes/assets/js/50.7bcea9dd.js"><link rel="prefetch" href="/notes/assets/js/51.7f1b0a3b.js"><link rel="prefetch" href="/notes/assets/js/52.ffc9f702.js"><link rel="prefetch" href="/notes/assets/js/53.508de3f8.js"><link rel="prefetch" href="/notes/assets/js/54.460c5416.js"><link rel="prefetch" href="/notes/assets/js/55.e6c4cdcc.js"><link rel="prefetch" href="/notes/assets/js/56.c3fa71d9.js"><link rel="prefetch" href="/notes/assets/js/57.7c19fcf4.js"><link rel="prefetch" href="/notes/assets/js/58.61a71708.js"><link rel="prefetch" href="/notes/assets/js/59.603db029.js"><link rel="prefetch" href="/notes/assets/js/6.599552f9.js"><link rel="prefetch" href="/notes/assets/js/60.a745b0d9.js"><link rel="prefetch" href="/notes/assets/js/61.6788cd7b.js"><link rel="prefetch" href="/notes/assets/js/62.a0b08dd5.js"><link rel="prefetch" href="/notes/assets/js/63.fcbfeaaa.js"><link rel="prefetch" href="/notes/assets/js/64.ca8ab83a.js"><link rel="prefetch" href="/notes/assets/js/65.2b923ced.js"><link rel="prefetch" href="/notes/assets/js/66.0e2a480b.js"><link rel="prefetch" href="/notes/assets/js/67.32823465.js"><link rel="prefetch" href="/notes/assets/js/68.a51c69cc.js"><link rel="prefetch" href="/notes/assets/js/69.3574bbf1.js"><link rel="prefetch" href="/notes/assets/js/70.351b7d00.js"><link rel="prefetch" href="/notes/assets/js/71.80810d3d.js"><link rel="prefetch" href="/notes/assets/js/72.52ef13c4.js"><link rel="prefetch" href="/notes/assets/js/73.92710d74.js"><link rel="prefetch" href="/notes/assets/js/74.49d2a943.js"><link rel="prefetch" href="/notes/assets/js/75.8357ede5.js"><link rel="prefetch" href="/notes/assets/js/76.41242c03.js"><link rel="prefetch" href="/notes/assets/js/77.2a85280b.js"><link rel="prefetch" href="/notes/assets/js/78.7cbf24df.js"><link rel="prefetch" href="/notes/assets/js/79.1c97a289.js"><link rel="prefetch" href="/notes/assets/js/8.51c84e7b.js"><link rel="prefetch" href="/notes/assets/js/80.467b67b4.js"><link rel="prefetch" href="/notes/assets/js/81.9c8960d9.js"><link rel="prefetch" href="/notes/assets/js/9.eb348a45.js"><link rel="prefetch" href="/notes/assets/js/vuejs-paginate.a59a2aec.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.5f1d73a0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/notes/" class="nav-link home-link">糖小米 . </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/notes/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/notes/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/notes/" class="nav-link mobile-home-link">糖小米 . </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/notes/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/notes/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        实时协同编辑的实现
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-12-01T00:00:00.000Z">
      Wed Dec 01 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/notes/tag/前端" data-v-42ccfcd5><span data-v-42ccfcd5>前端</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/notes/tag/javascript" data-v-42ccfcd5><span data-v-42ccfcd5>javascript</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。</p> <p>这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。</p> <p>要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。</p> <p>接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。
</p> <p>编辑锁这是实现协同编辑最简单的方法，简单来说就是当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑，因为实现简单，所以这个方案是应用最广的，比如公司内部常用的 TWiki 系统，采用这种方式虽然可以在一定程度上避免覆盖问题，但它的使用体验不好，也做不到「实时」，所以这里就不讨论了。</p> <p>Git 等版本管理软件其实也是一种协同编辑工具，因为每个人都可以并行编辑，遇到编辑同一个文件时可以自动合并，因此我们也能使用类似的原理来实现协同编辑，具体可以有两种方法：diff-patch 和 merge。</p> <p>先说 diff-patch，这里的 diff 和 patch 是指两个 unix 下的命令，diff 能输出两个文本的不同之处，然后用 patch 来更新其它文件，我们只要在 JS 中实现这两个算法，就能通过如下流程来实现协同编辑：</p> <ol><li>每个用户进来时都建立长连接，保存好当前文档副本</li> <li>有人编辑时，如果停顿 5 秒（具体要根据产品策略），就将现有文档和之前的副本进行 diff，将结果传给服务端，更新副本</li> <li>服务端更新文档，然后通过长连接将这个 diff 结果发给同时在编辑的其它用户，这些用户使用 patch 方法来更新 ta 们文档</li></ol> <p>但 GNU diff 有个问题，因为基于行匹配的，所以很容易冲突，让我们测试一下「百度 Web」和「百度 Web 前端」这两段文本的 diff 结果</p> <div class="language- extra-class"><pre class="language-text"><code>[nwind@fex ~]$ diff old.txt other-new.txt &gt; old-to-other-new.patch
[nwind@fex ~]$ cat old-to-other-new.patch
1c1
&lt; 百度 Web
---
&gt; 百度 Web 前端
</code></pre></div><p>在这个 diff 结果中， <code>1c1</code> 的第一个「1」代表修改前的第一行，后面的「c」代表「修改」，第二个「1」代表修改后的行，也就是说将第一行的「百度 Web」改成「百度 Web 前端」，修改后的内容放第一行。也就意味着如果两人同时修改一行就会冲突，可以通过下面的测试来确认：</p> <div class="language- extra-class"><pre class="language-text"><code>[nwind@fex ~]$ cat my-new.txt
Web [nwind@fex ~]$ patch my-new.txt &lt; old-to-other-new.patch
patching file b-new.txt
Hunk #1 FAILED at 1.
1 out of 1 hunk FAILED -- saving rejects to file my-new.txt.rej [nwind@fex ~]$ cat my-new.txt.rej
***************
*** 1
- 百度 Web--- 1 -----
+ 百度 Web 前端
</code></pre></div><p>其中 <code>my-new.txt</code> 是我修改的版本，我去掉了前面的「百度 」，只留下「Web」，其实这两处修改是不冲突的，它们可以合并成「Web 前端」，如下图所示</p> <p><img src="/notes/note_images/AC95FFF1-AACF-45D4-9922-64DFBC6E0FDF-401-000007B437174234/merge.png" alt="merge.png">
但使用 patch 命令部下，它在冲突后会生成一个新文件 <code>my-new.txt.rej</code> 来描述失败原因，这种展现方式不直观，需要打开两个文件比对，我们使用另一种方式来更好地展现，那就是接下来介绍的 merge 命令，它的使用方法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>[nwind@fex ~]$ merge my-new.txt old.txt other-new.txt
merge: warning: conflicts during merge [nwind@fex ~]$ cat my-new.txt
&lt;&lt;&lt;&lt;&lt;&lt;&lt; my-new.txt
Web=======
百度 Web 前端&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-new.txt
</code></pre></div><p>可以看到它直接将冲突的地方写到 <code>my-new.txt</code> 里了，这点比 patch 看起来要方便些，对于这个结果估计大部分同学都会眼熟，因为 merge 命令和 Git 等工具 <a href="https://github.com/git/git/blob/master/Documentation/git-merge.txt#L211" target="_blank" rel="noopener noreferrer">中的合并算法是一样的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p> <p>通过使用我们可以发现 merge 命令有个缺点，那就是需要使用 3 份完整的文本来进行比较，为了避免每次传递所有文本内容，我们可以结合使用 diff 来减小传输体积，在后端 patch 成新的文本。</p> <p>无论是 diff 还是 merge，由于它们的算法都是基于行进行比较，导致对同一行的编辑必然冲突，为了解决这个问题，我们可以尝试基于字符粒度的 diff 算法，那就是接下来将介绍的 Myer’s diff-patch。</p> <p><a href="http://neil.fraser.name/software/diff_match_patch/myers.pdf" target="_blank" rel="noopener noreferrer">Myer 算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是另一种 diff-patch 算法，它有很多 <a href="https://code.google.com/p/google-diff-match-patch/" target="_blank" rel="noopener noreferrer">语言的开源实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，这里我们就不介绍细节算法了，直接用之前的例子来测试它的效果，首先看一下它的 diff 结果，调用代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var old_text = &quot;百度 Web&quot;;
var new_text = &quot;百度 Web 前端&quot;; var dmp = new diff_match_patch();
var patch_list = dmp.patch_make(old_text, new_text);
patch_text = dmp.patch_toText(patch_list); console.log(decodeURI(patch_text))
</code></pre></div><p>输出结果为</p> <div class="language- extra-class"><pre class="language-text"><code>@@ -1,6 +1,9 @@
 百度 Web
+ 前端
</code></pre></div><p>其中第一行的 <code>-</code> 和 <code>+</code> 两个符号没有什么意义，这句话表示修改处之前的起始位置为 1（由于数组是从 0 开始的，所以内部计算时会先减一），长度为 6，后面的 <code>1,9</code> ，表示修改后的起始位置为 1，长度为 9。在接下来的两段文本代表修改的地方，注意「百度 Web」前面有空格，这代表相等，也就是直接添加这个字符串，而后面的 <code>+</code> 代表添加文本，具体细节可以通过它的 <a href="https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js#2100" target="_blank" rel="noopener noreferrer">实现源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 了解。</p> <p>因此确定它的 diff 策略是基于字符匹配的，这样能否解决我们之前遇到的冲突问题呢？接下来来测试一下，源码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>//相关代码同上
var patches = dmp.patch_fromText(patch_text);
var results = dmp.patch_apply(patches, &quot;Web&quot;); console.log(results[0]); //Web 前端
</code></pre></div><p>这个输出结果是正确的，也就是说它能很好地解决之前的问题，但如果是同一个位置的修改会怎样？我继续做了几个实验：</p> <div class="language- extra-class"><pre class="language-text"><code>var old_text = &quot;百度 Web&quot;;
var other_new_text = &quot;百度 Web 后端&quot;;
var my_new_text = &quot;百度 Web 前端&quot;;
...
//结果为「百度 Web 前端 后端」 ===
var old_text = &quot;百度 Web 前端&quot;;
var other_new_text = &quot;百度 Web 后端&quot;;
var my_new_text = &quot;百度 Web 全端&quot;;
...
//结果为「百度 Web 后端」 ===
var old_text = &quot;百度 Web&quot;;
var other_new_text = &quot;Web 前端&quot;;
var my_new_text = &quot;百度 FE&quot;;
//结果为「FE 前」
</code></pre></div><p>第一个例子是在后面添加不同的字符，它的结果是两个添加都生效，第二个例子是在同一处修改成不同的字符，它的结果是别人的修改生效，但最后一个例子出错了，丢失了「端」字，这里看起来还好，但如果内容是富文本就有问题了，比如 <code>&lt;b&gt;</code> 少了 <code>&gt;</code> 是不行的。</p> <p>整体来看 Myer 算法可以低成本地解决大部分问题，所以有些在线编辑器选择它来实现协同编辑功能，比如 <a href="http://codebox.io" target="_blank" rel="noopener noreferrer">codebox<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，它的客户端代码 <a href="https://github.com/FriendCode/codebox/blob/master/client/utils/filesync.js" target="_blank" rel="noopener noreferrer">在这<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，服务端代码 <a href="https://github.com/FriendCode/codebox/blob/master/core/cb.files.sync/models/document.js" target="_blank" rel="noopener noreferrer">在这<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p> <p>不过 Myer 在某些情况下会丢字符，是否还有更好的方法？答案是有，那就是接下来介绍的 Operational Transformation 技术。</p> <p>Operational Transformation（下面简称 OT）技术正是 Google Docs 中所采用的方案，因此是经过验证的，值得研究。</p> <p>最开始我一直觉得 OT 会很复杂，因为它的相关介绍文章都写得很长，比如 <a href="http://www3.ntu.edu.sg/home/czsun/projects/otfaq/" target="_blank" rel="noopener noreferrer">这篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 及维基百科上的 <a href="http://en.wikipedia.org/wiki/Operational_transformation" target="_blank" rel="noopener noreferrer">介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，不过看了之后才后发现它的原理并不复杂，我将在这里进行简单的说明。</p> <p>首先，我们可以将文本内容修改转成以下 3 种类型的操作(Operational)：</p> <ul><li>retain(n)：保持 n 个字符，也就是说这 n 个字符不变</li> <li>insert(str)：插入字符 str</li> <li>delete(str)：删除字符 str</li></ul> <p>举个例子，假设 A 用户将「百度 Web」变成「Web 前端」，相当于产生了如下 3 个操作：</p> <div class="language- extra-class"><pre class="language-text"><code>delete('百度 '),  //删掉「百度 」
retain(3),       //跳过 3 个字符（也就是「Web」）
insert(' 前端')   //插入「 前端」
</code></pre></div><p>提取这些操作可以通过 Levenshtein distance（编辑距离）算法来实现。那它如何解决冲突问题了？比如这时如果 B 用户将「百度 Web」改成了「百度 FE」，B 所生产的操作步骤将会是如下：</p> <div class="language- extra-class"><pre class="language-text"><code>retain(3),       //跳过 3 个字符（也就是「百度 」）
delete('Web'),
insert('FE')
</code></pre></div><p>如果我们先应用 A 的操作，将字符串变为「Web 前端」，然后再应用 B 的操作时就会失效，因为在执行 B 的第二个操作 <code>delete('Web')</code> 时并没有「Web」，这时从第四个字符开始已经变成了「 前端」。</p> <p>因此我们需要转换 B 的操作来适应新的字符串，比如调成如下操作：</p> <div class="language- extra-class"><pre class="language-text"><code>delete('Web'),
insert('FE'),
retain(3)
</code></pre></div><p>这个转换算法就是 OT 的核心，实际上 OT 指的是一类技术，而不是具体的算法，这个思路就是首先将编辑转成操作(Operational)，如果多人操作同时进行，需要对这些操作进行转换(Transformation)，这就是为什么叫 Operational Transformation，而具体应该拆分成哪些操作以及转换算法都是可以自定义的，因此 OT 可以灵活地支持各种协同编辑应用，比如非文本类的编辑。</p> <p>回到之前 Myer 算法导致丢字符的那个例子，我们看看 OT 是否能解决，这里我使用了一个开源库 <a href="https://github.com/marcelklehr/changesets" target="_blank" rel="noopener noreferrer">changesets<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，以下是基于它实现合并的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>var Changeset = require('changesets').Changeset; var text = &quot;百度 Web&quot; , textA = &quot;Web 前端&quot; , textB = &quot;百度 FE&quot;; var csA = Changeset.fromDiff(text, textA);
var csB = Changeset.fromDiff(text, textB); var csB_new = csB.transformAgainst(csA); //这里这就是操作转换 var textA_new = csA.apply(text);
console.log(csB_new.apply(textA_new)); //结果是「 前端FE」
</code></pre></div><p>结果并不正确，正确的应该是「FE 前端」，查看一下 <code>csB_new</code> 的内容，发现它实际上是转换成了如下操作：</p> <div class="language- extra-class"><pre class="language-text"><code>delete(3),   //注意 changesets 在这里的参数不是字符串而是数字，它会直接删掉 3 个字符，不够内容是什么
retain(3),
insert('FE')
</code></pre></div><p>需要注意这并不是 OT 技术本身的问题，而是 changesets 所实现的转换算法问题，虽然不够完美，但和之前的 Myer 算法相比，至少没丢字符，后来我又做了几个测试，发现 OT 技术的准确率比 Myer 高，因此它是最适合用于协同编辑的技术。</p> <p>如果看完上面的文章你觉得实现实时协同编辑似乎不难，那你就错了，因为我们之前都没有考虑分布式的问题，OT 技术在学术界都研究 20 多年了，至今也没人总结出一个最好的方法，前 Google Wave 工程师在 <a href="http://sharejs.org/" target="_blank" rel="noopener noreferrer">ShareJS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 首页上这样写道：</p> <blockquote><p>Unfortunately, implementing OT sucks. There’s a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. I am an ex Google Wave engineer. Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.</p></blockquote> <p>所以其实要做好是很难的，这里面最麻烦的就是分布式导致的问题，接下来将介绍 3 个我能想到的问题及解决方法。</p> <p><strong>1. 顺序问题</strong></p> <p>首先第一个问题是顺序问题，因为 OT 等算法都是依赖顺序的，不同顺序会导致结果不同，我们通过下面这张图来说明：</p> <p><img src="/notes/note_images/61C2F63E-CB80-4158-A550-8ED2523B1871-401-000007B436F6EBEA/order-problem.png" alt="order-problem.png">
假设 <code>Client A</code> 在做两次修改时发了两个异步请求，可能因为网络延迟导致第二个请求反而先到了，导致最终服务器版本和 <code>Client A</code> 所看到的不一致，同样在服务器发往其它客户端的请求时也会出现乱序的问题，如图中 <code>Client B</code> 也有问题。</p> <p>这个问题的解决方法很简单，我们可以在客户端和服务器端都加上队列来保证请求顺序，等前一个请求结束后再发下一个请求。</p> <p><strong>2. 存储的原子操作</strong></p> <p>如果有多台服务器，或者有多个线程/进程在同时处理请求时就会遇到覆盖问题，因为读写数据库并不是原子操作，比如下面的例子：</p> <p><img src="/notes/note_images/37D9CB53-A7A9-4545-8337-1B46E418BE5F-401-000007B436D72DD5/data-atomic.png" alt="data-atomic.png"> <code>Web Server A</code> 和 <code>Web Server B</code> 同时访问数据库，结果导致 <code>Web Server A</code> 的修改被覆盖了。</p> <p>好在这种问题还算比较常见，解决办法可以有 3 种：</p> <ul><li>保证操作只在一个线程中执行，比如某个文档的更新只在某个固定的机器，使用 Node 这样的单线程模型提供服务，这样就不可能并行修改了</li> <li>如果数据库支持事务(transaction)，可以通过事务来解决</li> <li>如果数据库不支持事务，就只能用分布式锁了，如 ZooKeeper</li></ul> <p>从实现角度来看，第一和第二种方法都比较简单，而第三种方法会带来很多问题，比如可能导致文档被锁死，假如上锁后由于种种原因没有执行解锁操作，这个文档就会永远被锁住，所以还得加上超时限制等策略。</p> <p>然而在解决了原子操作后，我们将发现一个新的问题，那就是版本管理问题。</p> <p><strong>3. 版本管理问题</strong></p> <p>在前面的例子中，两段新文本的修改都是基于同一个旧版本的，如果旧版本不一样，就有可能出错，具体可以通过下面这张图来解释：</p> <p><img src="/notes/note_images/DC4A4083-25DF-4D9F-9BEA-138FE5CC6D18-401-000007B436BC1F19/version-problem.png" alt="version-problem.png">
在这个例子中，Web Server A 接收到操作命令是将「a」文本改成「aa」，Web Server B 接收到操作命令是将「a」文本改成「ab」，这里我们加上了锁机制来避免同时读写数据，Web Server A 首先得到了锁，然后修改并更新数据，而 Web Server B 需要先等待数据解锁，等 Web Server B 拿到数据后它已经从「a」变成了「aa」，如果还按照 <code>retain(1), insert('b')</code> 进行修改，数据将变成「ab」，而不是正确的「aab」，引起这个问题的原因就是旧版本不一致，Web Server B 需要根据 Web Server A 的操作进行操作转换，变成 <code>retain(2), insert('b')</code> ，然后才能对数据进行修改。</p> <p>因此想要解决这个问题，就必须引入版本，每次修改后都需要存储下新版本，有了版本我们就能使用 diff 功能来计算不同版本的差异，得到其它人修改的内容，然后通过 OT 合并算法合并两个操作，如下所示：</p> <p><img src="/notes/note_images/901AC6E0-E7ED-4CC0-BCE0-1256AFA161D2-401-000007B4369BF595/version-solution.png" alt="version-solution.png">
在 <code>Web Server A</code> 操作前数据版本是 <code>v=1</code> ，操作后变成了 <code>v=2</code> ，等到 <code>Web Server B</code> 处理的时候，它通过版本比较发现不一致，所以就首先通过编辑距离算法算出 <code>Web Server A</code> 所做的操作，然后用这个操作来对自己的操作进行转换，得到正确的新操作，从而避免了覆盖问题。</p> <p>如果保存所有版本会导致数据量大大增加，所以还需要再优化，比如每个服务器保存一个数据副本，但这里就不再展开了，可以看要支持分布式 还是挺麻烦的，不过目前出现了一些前后端整合的方案，如 <a href="http://sharejs.org/" target="_blank" rel="noopener noreferrer">ShareJS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/opencoweb/coweb" target="_blank" rel="noopener noreferrer">OpenCoweb Framework<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，可以参考。</p> <p>另外之前提到的 Myer’s diff 算法也有分布式解决方案，具体细节可以参考 <a href="https://neil.fraser.name/writing/sync/" target="_blank" rel="noopener noreferrer">这篇文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p> <ul><li><p>如果你只是一个内部小项目，实时性要求不高，但对准确性要求比较高</p> <ul><li>推荐用 merge 或 diff3 工具，出现同一行冲突时由用户来解决，这样能避免自动合并有可能出错的问题</li></ul></li> <li><p>如果想具备一定的实时性，流量不大，不想实现太复杂，且对少量的冲突可以忍受</p> <ul><li>推荐用 Myer’s diff，后端只开一个 Node 进程</li></ul></li> <li><p>如果想具备实时性，且有多台后端服务同时处理</p> <ul><li>可以用 Operational Transformation 或 Myer’s diff，但需要注意分布式带来的问题</li></ul></li> <li><p>如果需要很精细的控制，如支持富文本编辑等非单纯文本格式</p> <ul><li>只能使用 Operational Transformation，但要自己实现操作合并算法，比如 XML 可以参考 <a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation" target="_blank" rel="noopener noreferrer">这篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <p>除了文本合并，真正要做在线编辑还有很多细节处理，感兴趣的同学可以继续研究：</p> <ul><li>支持选区，看到其他人选择的文本段，当然，这也有合并问题</li> <li>指针要更随文本变化移动到正确的位置</li> <li>支持 undo</li></ul> <p><a href="https://fex.baidu.com/blog/2014/04/realtime-collaboration/" target="_blank" rel="noopener noreferrer">实时协同编辑的实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer><!----> <hr> <!----></footer></article> <!----></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/im" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li><li class="contact-item" data-v-3d9deeb8><a href="mailto:tangxiaomiemail@gmail.com" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-3d9deeb8><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-3d9deeb8></path><polyline points="22,6 12,13 2,6" data-v-3d9deeb8></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>糖小米 © 2022</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.a25c93c4.js" defer></script><script src="/notes/assets/js/7.4afd0a91.js" defer></script><script src="/notes/assets/js/1.208cd082.js" defer></script><script src="/notes/assets/js/48.64b07b58.js" defer></script>
  </body>
</html>
