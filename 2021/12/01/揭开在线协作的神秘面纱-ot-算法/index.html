<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>揭开在线协作的神秘面纱 – OT 算法 | 糖小米 .</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/notes/favicon.ico">
    <meta name="description" content="
相信大家或多或少都有使用过在线文档，国内的像我们在做的 腾讯文档 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。

背景

在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。
富文本编辑器现在业界已经有很多成熟的产品 ...">
    
    <link rel="preload" href="/notes/assets/css/0.styles.5f1d73a0.css" as="style"><link rel="preload" href="/notes/assets/js/app.f0258b7e.js" as="script"><link rel="preload" href="/notes/assets/js/7.4afd0a91.js" as="script"><link rel="preload" href="/notes/assets/js/1.208cd082.js" as="script"><link rel="preload" href="/notes/assets/js/48.30f17979.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.47e74a21.js"><link rel="prefetch" href="/notes/assets/js/11.49994ff3.js"><link rel="prefetch" href="/notes/assets/js/12.203adc88.js"><link rel="prefetch" href="/notes/assets/js/13.87007fe1.js"><link rel="prefetch" href="/notes/assets/js/14.0fee2772.js"><link rel="prefetch" href="/notes/assets/js/15.57212f07.js"><link rel="prefetch" href="/notes/assets/js/16.48711904.js"><link rel="prefetch" href="/notes/assets/js/17.28a68dff.js"><link rel="prefetch" href="/notes/assets/js/18.cfe43cd4.js"><link rel="prefetch" href="/notes/assets/js/19.71636c62.js"><link rel="prefetch" href="/notes/assets/js/20.37aa4175.js"><link rel="prefetch" href="/notes/assets/js/21.806577aa.js"><link rel="prefetch" href="/notes/assets/js/22.88e1f851.js"><link rel="prefetch" href="/notes/assets/js/23.92731f46.js"><link rel="prefetch" href="/notes/assets/js/24.114b0c2c.js"><link rel="prefetch" href="/notes/assets/js/25.3c31df46.js"><link rel="prefetch" href="/notes/assets/js/26.3b0a7f01.js"><link rel="prefetch" href="/notes/assets/js/27.4fea17d8.js"><link rel="prefetch" href="/notes/assets/js/28.6b16c93d.js"><link rel="prefetch" href="/notes/assets/js/29.58ac9fa5.js"><link rel="prefetch" href="/notes/assets/js/30.3dbec0e6.js"><link rel="prefetch" href="/notes/assets/js/31.1d8f9c16.js"><link rel="prefetch" href="/notes/assets/js/32.2dd1762a.js"><link rel="prefetch" href="/notes/assets/js/33.db8913f1.js"><link rel="prefetch" href="/notes/assets/js/34.64ba0435.js"><link rel="prefetch" href="/notes/assets/js/35.c3e200a6.js"><link rel="prefetch" href="/notes/assets/js/36.2bf4c539.js"><link rel="prefetch" href="/notes/assets/js/37.c18afd54.js"><link rel="prefetch" href="/notes/assets/js/38.ae18cab1.js"><link rel="prefetch" href="/notes/assets/js/39.1faa2f04.js"><link rel="prefetch" href="/notes/assets/js/4.ffa57cc2.js"><link rel="prefetch" href="/notes/assets/js/40.deedd9c3.js"><link rel="prefetch" href="/notes/assets/js/41.608e8945.js"><link rel="prefetch" href="/notes/assets/js/42.bbd42f75.js"><link rel="prefetch" href="/notes/assets/js/43.56518cb7.js"><link rel="prefetch" href="/notes/assets/js/44.14b58115.js"><link rel="prefetch" href="/notes/assets/js/45.da3da00e.js"><link rel="prefetch" href="/notes/assets/js/46.f04ea11b.js"><link rel="prefetch" href="/notes/assets/js/47.247919bc.js"><link rel="prefetch" href="/notes/assets/js/49.a23d3462.js"><link rel="prefetch" href="/notes/assets/js/5.5d5ced76.js"><link rel="prefetch" href="/notes/assets/js/50.5fb687b2.js"><link rel="prefetch" href="/notes/assets/js/51.0468b01e.js"><link rel="prefetch" href="/notes/assets/js/52.f47f9e6f.js"><link rel="prefetch" href="/notes/assets/js/53.4aa9a0b6.js"><link rel="prefetch" href="/notes/assets/js/54.4753ebec.js"><link rel="prefetch" href="/notes/assets/js/55.8afc111e.js"><link rel="prefetch" href="/notes/assets/js/56.a10f840b.js"><link rel="prefetch" href="/notes/assets/js/57.0873d7e2.js"><link rel="prefetch" href="/notes/assets/js/58.9725c24c.js"><link rel="prefetch" href="/notes/assets/js/59.35690a5e.js"><link rel="prefetch" href="/notes/assets/js/6.599552f9.js"><link rel="prefetch" href="/notes/assets/js/60.0e48d77a.js"><link rel="prefetch" href="/notes/assets/js/61.80e80cb4.js"><link rel="prefetch" href="/notes/assets/js/62.7f3c47b7.js"><link rel="prefetch" href="/notes/assets/js/63.667777e9.js"><link rel="prefetch" href="/notes/assets/js/64.309211e6.js"><link rel="prefetch" href="/notes/assets/js/65.943eef42.js"><link rel="prefetch" href="/notes/assets/js/66.5f80abdd.js"><link rel="prefetch" href="/notes/assets/js/67.88033ac7.js"><link rel="prefetch" href="/notes/assets/js/68.ae7c1ee4.js"><link rel="prefetch" href="/notes/assets/js/69.fa74cf8f.js"><link rel="prefetch" href="/notes/assets/js/70.22a3b497.js"><link rel="prefetch" href="/notes/assets/js/71.166c6787.js"><link rel="prefetch" href="/notes/assets/js/72.9bd8151b.js"><link rel="prefetch" href="/notes/assets/js/73.e049855b.js"><link rel="prefetch" href="/notes/assets/js/74.2a0388b3.js"><link rel="prefetch" href="/notes/assets/js/75.2f42ac0e.js"><link rel="prefetch" href="/notes/assets/js/76.2e4e22b3.js"><link rel="prefetch" href="/notes/assets/js/77.24f75892.js"><link rel="prefetch" href="/notes/assets/js/78.eb90fc13.js"><link rel="prefetch" href="/notes/assets/js/79.57e6087a.js"><link rel="prefetch" href="/notes/assets/js/8.51c84e7b.js"><link rel="prefetch" href="/notes/assets/js/80.fd29ad69.js"><link rel="prefetch" href="/notes/assets/js/9.eb348a45.js"><link rel="prefetch" href="/notes/assets/js/vuejs-paginate.a59a2aec.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.5f1d73a0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/notes/" class="nav-link home-link">糖小米 . </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/notes/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/notes/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/notes/" class="nav-link mobile-home-link">糖小米 . </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/notes/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/notes/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        揭开在线协作的神秘面纱 – OT 算法
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-12-01T00:00:00.000Z">
      Wed Dec 01 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/notes/tag/前端" data-v-42ccfcd5><span data-v-42ccfcd5>前端</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/notes/tag/javascript" data-v-42ccfcd5><span data-v-42ccfcd5>javascript</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="揭开在线协作的神秘面纱-ot-算法"><a href="#揭开在线协作的神秘面纱-ot-算法" class="header-anchor">#</a> 揭开在线协作的神秘面纱 – OT 算法</h1> <p>相信大家或多或少都有使用过在线文档，国内的像我们在做的 <a href="http://https://docs.qq.com/desktop/" target="_blank" rel="noopener noreferrer">腾讯文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。</p> <h3 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h3> <p>在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。
富文本编辑器现在业界已经有很多成熟的产品，像 <a href="https://codemirror.net/" target="_blank" rel="noopener noreferrer">codeMirror<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，这一块本身也是很复杂的一块，也不是咱们这次关注的重点方向。
不知道大家平常在用这些产品的时候有没有思考过一个问题，在线文档编辑的时候产生冲突怎么办？
</p> <h3 id="举个栗子"><a href="#举个栗子" class="header-anchor">#</a> 举个栗子</h3> <p>举个很简单的例子，现在大家的文本都是 ‘aaab’，A 用户在第 3 个字符行后面插入了一个 ‘c’，B 用户在第 3 个字符行后面插入了一个 ‘d’，这个时候 A 这边看到的是 ‘aaacb’，B 这边看到的是 ‘aaadb’, 我们假设 A 用户先提交了数据，那其实最后预期的数据其实应该是 ‘aaacdb’，这样就最大的保存了每个人的输入。 那我们现在来看看正常情况下这里会发生什么：</p> <p>A 用户：</p> <blockquote><p>A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 <strong>第 3 个字符行后面插入了一个 ‘d’</strong> ，那 A 这边执行了这个行为，最终变成了 ‘aaadcb’</p></blockquote> <p>B 用户：</p> <blockquote><p>B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 <strong>第 3 个字符行后面插入了一个 ‘c’</strong> ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’</p></blockquote> <p>从上面的模拟过程可以看到，A 用户最后的结果其实是不正确的，但是 B 是正确的。</p> <p>这里先解释一下大家可能会疑惑的地方：为什么 B 是过一会儿后台告诉它 A 编辑了，不是说 A 先提交了数据吗？
其实这里针对的是冲突场景，这里如果 B 在提交之前，已经收到后台告诉它 A 编辑了，那其实就是顺序编辑了，也就不是冲突了。所以这里指的是 A，B 几乎同时提交，但是 A 到达后台还是快一点的，也就是 A，B 在编辑的时候是不知道彼此的存在的。</p> <p>真实的冲突场景其实不是这种简单的时序问题，这里我后面再介绍。</p> <h3 id="尝试解决"><a href="#尝试解决" class="header-anchor">#</a> 尝试解决</h3> <p>这里可能有一些聪明的小伙伴有了一些想法。</p> <h4 id="解决方案一-丢了丢了"><a href="#解决方案一-丢了丢了" class="header-anchor">#</a> 解决方案一：丢了丢了</h4> <p>这可能是最简单粗暴的方法了，我发现有冲突，就告诉用户，主子，咱这里有冲突了，臣妾解决不了啊。但是显然这会经常出现，然后主子就把你打入冷宫了。</p> <h4 id="解决方案二-锁"><a href="#解决方案二-锁" class="header-anchor">#</a> 解决方案二：锁</h4> <p>有些小伙伴想到，上面出现问题，还不是因为大家编辑了都立即应用了，我们编辑后不立即应用不就好了，而且历史告诉我们，有冲突加锁应该可以解决。那我们看看假如不立即应用，咱有没有什么处理办法：</p> <p>A 用户：</p> <blockquote><p>A 本地已经是 ‘aaab’ 了，A 编辑了，但是不应用，先发后台</p></blockquote> <p>B 用户：</p> <blockquote><p>B 本地已经是 ‘aaab’ 了，B 编辑了，但是不应用，先发后台</p></blockquote> <p>后台：</p> <blockquote><p>后台先收到 A 请求，然后加了一个锁，然后收到了 B 请求，这时侯应该是加锁的状态，所以接受了 A，拒绝了 B</p></blockquote> <p>A 用户：</p> <blockquote><p>A 用户收到了后台的回复，告诉它你的提交我接收了</p></blockquote> <p>B 用户：</p> <blockquote><p>B 用户收到了后台的回复，告诉它你的提交被我拒绝了，因为冲突了</p></blockquote> <p>这样虽然能继续下去，但是好像还是不太行的亚子啊，B 的提交还是丢了，所以好像和第一种简单粗暴的方法没啥区别</p> <h3 id="ot-算法"><a href="#ot-算法" class="header-anchor">#</a> OT 算法</h3> <p>顺其自然的，这个时候你会看到 OT 算法驾着七彩祥云来救你了～
其实回到上面的例子，本质问题还是因为后台通知大家的 B 的编辑行为看起来不太对。现在后台通知大家的是:</p> <blockquote><p>B 的编辑的行为就是 <strong>第 3 个字符行后面插入了一个 ‘d’</strong></p></blockquote> <p>但是在 A 已经接受的情况下，正确的通知应该是：</p> <blockquote><p>B 的编辑的行为就是 <strong>第 4 个字符行后面插入了一个 ‘d’</strong></p></blockquote> <p>假如我们把 A 提交的行为叫做 A，B 提交的行为叫做 B，现在后台就是一个简单的转发功能，告诉 A 的是 B，告诉 B 的是 A，然后就出现问题了。所以后台应该更聪明一点，它应该学会一个招术，那就是把每个人提交的行为转变一下再告诉别人，其实这个技术就是 OT 算法。</p> <p>OT 算法全名叫 <strong>Operation Transformation</strong> ，你看从名字就对应了上面我说的转变算法。 假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A',B'。 也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A'行为告诉 B，把 B'行为告诉 A，这样大家再应用就相安无事了。</p> <p><img src="/notes/note_images/F84B1BEA-D83B-468B-8519-4004771299A3-401-000006226F973DF8/0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png" alt="0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png"></p> <p>上面的图是 OT 的经典菱形图，也就是说 A 会变成 A'在 B 这边执行，B 会变成 B'在 A 这边执行。 这里实际抽象一下，用户永远就只有两个人，一个是自己，一个是服务端，只是服务端的操作可能来自很多人，如果不这样抽象，那一个个进行冲突处理可能会让你觉得无法理解。</p> <p>那我们现在再来看看后台有了 OT 这个能力之后会发生什么：</p> <p>A 用户：</p> <blockquote><p>A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 <strong>第 4 个字符行后面插入了一个 ‘d’</strong> ，那 A 这边执行了这个行为，最终变成了 ‘aaacdb’</p></blockquote> <p>B 用户：</p> <blockquote><p>B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 <strong>第 3 个字符行后面插入了一个 ‘c’</strong> ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’</p></blockquote> <p>现在 A、B 就一致了！</p> <h3 id="ot-算法的实现"><a href="#ot-算法的实现" class="header-anchor">#</a> OT 算法的实现</h3> <p>现在 OT 算法对我们来说就是一个黑盒，我们知道给一定的输入，它会有正确的输出，但是它是如何做到的呢？
在介绍它的实现之前，我们需要抽象一下我们的操作行为，在之前我们的描述都是</p> <blockquote><p><strong>第 3 个字符行后面插入了一个 ‘d’</strong></p></blockquote> <p>这里怎么转换成程序识别或者能用代码表达的呢？其实这也是 OT 的关键。 这里我直接揭晓答案：</p> <p>所有对文本的操作都可以抽象成三个原子行为：</p> <blockquote><p>R = Retain，保持操作 I = Insert，插入操作</p></blockquote> <blockquote><p>D = Delete，删除操作</p></blockquote> <p>那之前的行为</p> <blockquote><p><strong>第 3 个字符行后面插入了一个 ‘d’</strong></p></blockquote> <p>就会变成</p> <blockquote><p>R(3), I('d')</p></blockquote> <p>也就是保持三个字符后插入 1 个 ‘d’，其实应该也很好理解，这里的操作就像操作数组一样，不管干什么，第一步你得先找到操作的下标。
有了这三个原子以后，我们就可以看到：</p> <blockquote><p>A = R(3),I('c')
B = R(3), I('d')</p></blockquote> <p>一切准备就绪，我们可以开始看 OT 了，这里 OT 算法现在已经很成熟了，这里我以一个 github 上的 repo 为例： <a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="noopener noreferrer">ot.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
我们可以看看它的核心代码 (有删减，理解起来可能会比较复杂，感兴趣的可以深入思考一下)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Transform takes two operations A and B that happened concurrently and</span>
  <span class="token comment">// produces two operations A' and B' (in an array) such that</span>
  <span class="token comment">// `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the</span>
  <span class="token comment">// heart of OT.</span>
  <span class="token comment">// 上面这个公式就是OT的核心，它产生了A',B',同时保证执行结果一致，S就是我们开始的状态，可以把这个和菱形图对应起来</span>
  <span class="token comment">// 整体执行流程有点像合并排序的过程。两个下标指针分别往前走</span>
 
  TextOperation<span class="token punctuation">.</span><span class="token function-variable function">transform</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">operation1<span class="token punctuation">,</span> operation2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// operation1， operation2就是我们的A，B</span>
 
    <span class="token keyword">var</span> operation1prime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 就是A'</span>
    <span class="token keyword">var</span> operation2prime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 就是B'</span>
    <span class="token keyword">var</span> ops1 <span class="token operator">=</span> operation1<span class="token punctuation">.</span>ops<span class="token punctuation">,</span> ops2 <span class="token operator">=</span> operation2<span class="token punctuation">.</span>ops<span class="token punctuation">;</span>
    <span class="token keyword">var</span> i1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> op1 <span class="token operator">=</span> ops1<span class="token punctuation">[</span>i1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> op2 <span class="token operator">=</span> ops2<span class="token punctuation">[</span>i2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// At every iteration of the loop, the imaginary cursor that both</span>
      <span class="token comment">// operation1 and operation2 have that operates on the input string must</span>
      <span class="token comment">// have the same position in the input string.</span>
      <span class="token comment">// 其实这里就是说transform的核心是保证两者的下标一致，这样操作的才是同一个位置的数据</span>
      <span class="token comment">// ...</span>
      <span class="token comment">// next two cases: one or both ops are insert ops</span>
      <span class="token comment">// =&gt; insert the string in the corresponding prime operation, skip it in</span>
      <span class="token comment">// the other one. If both op1 and op2 are insert ops, prefer op1.</span>
      <span class="token comment">// 如果A是插入操作，A'一定也是插入，但是B'就不一样了，因为A是插入，不管你B是啥，你先等等，所以retain一下，保证下标一致</span>
      <span class="token comment">// 这里实际上有三种情况，A是插入，B可能是R，I，D</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInsert</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        operation1prime<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        operation2prime<span class="token punctuation">.</span><span class="token function">retain</span><span class="token punctuation">(</span>op1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        op1 <span class="token operator">=</span> ops1<span class="token punctuation">[</span>i1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果B也是插入，那B’就是插入，但是你的A'也得retain一下，保证下标一致</span>
      <span class="token comment">// 这里可能有两者情况，A可能是R，D</span>
      <span class="token comment">// 实例化思考一下，A [R(3),I('a')],B [I('b')],那对于A'来说就应该是[R(4),I('a')]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInsert</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        operation1prime<span class="token punctuation">.</span><span class="token function">retain</span><span class="token punctuation">(</span>op2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        operation2prime<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        op2 <span class="token operator">=</span> ops2<span class="token punctuation">[</span>i2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// ...</span>
      <span class="token keyword">var</span> minl<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRetain</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRetain</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// R和R处理</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDelete</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDelete</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//D和D处理</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDelete</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRetain</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// D和R处理</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRetain</span><span class="token punctuation">(</span>op1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDelete</span><span class="token punctuation">(</span>op2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//R和D处理</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>operation1prime<span class="token punctuation">,</span> operation2prime<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>这里就是 OT 的 transform 实现，本质上就是把用户的原子操作数组拿到以后，然后做 transform 操作，这里我只选了一小段来大概解析下，具体的可以看注释，其实原本的注释已经很全了。 其实上面那段代码，因为我们的原子操作只有三种，根据排列组合，最多只会有 9 种情况，只是上面把很多情况合并了，你要是不理解，也可以拆开，帮助理解。</p> <p>其实上面的文件还有 compose，invert 等方法，但是其实 transform 才是我们理解的核心，其他方法大家感兴趣可以看看注释和下面贴的一些关于 OT 更详细介绍的文章。</p> <h3 id="ot-算法的时序"><a href="#ot-算法的时序" class="header-anchor">#</a> OT 算法的时序</h3> <p>简单的 OT 大家只要理解了，好像也并不是很难，但是其实真实情况下 OT 会比想象的还要复杂，因为之前说的菱形会无限拓展。</p> <p><img src="/notes/note_images/94B2B904-361D-47D5-AE54-7BC82BCB48AD-401-000006226F75F86E/6E64DEED-65D3-42F9-8485-59C84C0FCD6C-300x124.jpg" alt="6E64DEED-65D3-42F9-8485-59C84C0FCD6C-300x124.jpg"></p> <p>简单理解一下，就是 A 本地产生了两次编辑，B 产生了一次。这里就必须要和大家解释一下之前遗留的时序问题了，不然可能无法理解。</p> <p>之前说的时序都是指时间先后顺序，冲突也是指同时产生编辑。但是其实这里的同时不是时间上的同时，而是 <code>版本上的同时</code> 。 也就是说我们需要用一个东西表示每一个版本，类似 git 的每次提交，每次提交到服务端的时候就要告诉后端，我的修改是基于哪个版本的修改。</p> <p>最简单的标志位就是 <code>递增的数字</code> 。那基于版本的冲突，可以简单理解为我们都是基于 100 版本的提交，那就是冲突了，也许我们并不是同时， <code>谁先到后台决定了谁先被接受而已</code> 。这里最夸张的就是离线编辑，可能正常版本已经到了 1000 了，某个用户因为离线了，本地的版本一直停留在 100，提交上来的版本是基于 100 的。</p> <p>那有了时序的概念，我们再看上面这个菱形，它可以理解成 A 和 B 都基于 100 提交了数据，但是在 A 的提交还没被后台确认的时候，A 又编辑了，但是因为上一次提交没被确认，所以这次不会发到后台，这时服务器告诉它 B 基于 100 做了提交。</p> <p>这种情况下如何处理，就有点类似于 OT 落地到实践当中，你怎么实现了，上面提到的 github 的那个 repo 的实现其实非常巧妙，你看完注释应该就能全部理解，这里给出 <a href="https://github.com/Operational-Transformation/ot.js/blob/8873b7e28e83f9adbf6c3a28ec639c9151a838ae/lib/client.js" target="_blank" rel="noopener noreferrer">代码链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>精华就在于它把本地分成了几个状态：</p> <blockquote><p>Synchronized 没有正在提交并且等待回包的 operation AwaitingConfirm 有一个 operation 提交了但是等后台确认，本地没有编辑数据</p></blockquote> <blockquote><p>AwaitingWithBuffer 有一个 operation 提交了但是等后台确认，本地有编辑数据</p></blockquote> <p>剩下的就是在这三种状态下，收到了本地和服务端的数据，分别应该怎么处理</p> <h3 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h3> <p>其实 OT 对应的只是一种思想，具体怎么实现是根据具体情况来区分的，比如我们现在讨论的就是文本的 OT，那有可能图的 OT、表格的 OT 又是其他的实现。OT 的核心就是 transform，而 transform 的核心就在于你怎么找到这样的原子操作了，然后原子操作的复杂度决定了 transform 实现的复杂度。</p> <p>上面这个 repo 只是帮你实现了文本的协同处理，其实对于在线文档来说，还有样式的冲突处理，感兴趣的可以自己搜索相关资料了解一下，建议精读一下 ot.js 这个库。</p> <p>最后如果读完这篇文章你对在线协作有了一定的认知，那这篇文章的使命也就达到了，最后如果有写的不正确的地方，欢迎斧正～</p> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h3> <p><a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation" target="_blank" rel="noopener noreferrer">understanding-and-applying-operational-transformation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="noopener noreferrer">ot.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://www.alloyteam.com/2019/07/13659/" target="_blank" rel="noopener noreferrer">揭开在线协作的神秘面纱 – OT 算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#背景" title="背景">背景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#举个栗子" title="举个栗子">举个栗子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#尝试解决" title="尝试解决">尝试解决</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ot-算法" title="OT 算法">OT 算法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ot-算法的实现" title="OT 算法的实现">OT 算法的实现</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ot-算法的时序" title="OT 算法的时序">OT 算法的时序</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#结语" title="结语">结语</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#参考资料" title="参考资料">参考资料</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/im" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li><li class="contact-item" data-v-3d9deeb8><a href="mailto:tangxiaomiemail@gmail.com" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-3d9deeb8><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-3d9deeb8></path><polyline points="22,6 12,13 2,6" data-v-3d9deeb8></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>糖小米 © 2022</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.f0258b7e.js" defer></script><script src="/notes/assets/js/7.4afd0a91.js" defer></script><script src="/notes/assets/js/1.208cd082.js" defer></script><script src="/notes/assets/js/48.30f17979.js" defer></script>
  </body>
</html>
